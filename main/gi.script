go.property('bounds_min', vmath.vector3(-10, -10, -10))
go.property('bounds_max', vmath.vector3(10, 10, 10))

local SETTINGS = require "settings"

local geometry
local lights
local faces = {}
local meshes = {}

local PROBES_PER_ROW = 4

local tbuffer
local device
local program
local kernel


local function load_probes_into_texture(self)
	--each probe (9 sh coefficients) will be stored in 3 rgb texels
		
	local tstream = buffer.get_stream(tbuffer, hash("rgb"))

	-- Fill the buffer stream with float values

	local index = 1
	for y = 1, PROBES_PER_ROW do
		for x = 1, PROBES_PER_ROW do
			for z = 1, PROBES_PER_ROW do
				local pi = (y - 1) * PROBES_PER_ROW * PROBES_PER_ROW + (x-1) * PROBES_PER_ROW + z
				local probe = self.probes[pi]
	
				tstream[index + 0] = probe.coef[1]
				tstream[index + 1] = probe.coef[2]
				tstream[index + 2] = probe.coef[3]
				
				tstream[index + 3] = probe.coef[4]
				tstream[index + 4] = probe.coef[5]
				tstream[index + 5] = probe.coef[6]
				
				tstream[index + 6] = probe.coef[7]
				tstream[index + 7] = probe.coef[8]
				tstream[index + 8] = probe.coef[9]

				index = index + 9
			end
		end
	end

	local tparams = {
		width          = PROBES_PER_ROW * PROBES_PER_ROW * 3,
		height         = PROBES_PER_ROW,
		type           = resource.TEXTURE_TYPE_2D,
		format         = resource.TEXTURE_FORMAT_RGB32F,
	}

	-- Note that we pass the buffer as the last argument here!
	resource.set_texture(self.my_texture_id, tparams, tbuffer)
	
end


local function calculate_probes(self)
	
	local sec = kernel:run(2, {256, #self.probes}, {256, 1})
	--pprint("Kernel run in " .. sec .. " seconds")

	kernel:read(9, 9 * #self.probes, self.pbuffer, "data")
	for i, probe in ipairs(self.probes) do
		for j = 1, 9 do 
			probe.coef[j] = self.pstream[(i - 1) * 9 + j];
		end
		go.set(probe.model, "coefs", vmath.vector4(probe.coef[1], probe.coef[2], probe.coef[3], probe.coef[4]), {index = 1})
		go.set(probe.model, "coefs", vmath.vector4(probe.coef[5], probe.coef[6], probe.coef[7], probe.coef[8]), {index = 2})
		go.set(probe.model, "coefs", vmath.vector4(probe.coef[9], 0, 0, 0), {index = 3})
	end

	load_probes_into_texture(self)
end

function init(self)
	self.time = 0;
	self.t = 0;
	self.pbuffer = buffer.create(PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW * 9, { {name=hash("data"), type=buffer.VALUE_TYPE_FLOAT32, count=1} } )
	self.pstream = buffer.get_stream(self.pbuffer, hash("data"))

	tbuffer = buffer.create(PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW * 3, { {name=hash("rgb"), type=buffer.VALUE_TYPE_FLOAT32, count=3} } )
	
	local src = sys.load_resource("/programs/raytrace.c") -- opencl kernel code
	local devices = opencl.get_devices(true)

	device = devices[1]
	program = device:load_program(src)

	imgui.set_ini_filename()
	self.count = 0
	self.probes = {}
	math.randomseed(os.clock()*100000)

	timer.delay(.1, false, function()

		local tparams = {
			width          = PROBES_PER_ROW * PROBES_PER_ROW * 3,
			height         = PROBES_PER_ROW,
			type           = resource.TEXTURE_TYPE_2D,
			format         = resource.TEXTURE_FORMAT_RGB32F,
		}

		-- Note that we pass the buffer as the last argument here!
		self.my_texture_id = resource.create_texture("/probes.texturec", tparams, tbuffer)

		-- assign the texture to a model
		for _, mesh in ipairs(meshes) do
			go.set(mesh, "texture1", self.my_texture_id)
		end

		go.set("/preview#mesh", "texture0", self.my_texture_id)
		
		geometry = buffer.create(#faces * 3, { -- input data for opencl kernel
			{ name = hash("positions"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
			{ name = hash("normals"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		})

		local positions = buffer.get_stream(geometry, hash("positions"))
		local normals = buffer.get_stream(geometry, hash("normals"))

		local count = 0
		for _, face in ipairs(faces) do
			positions[count + 1] = face.v[1].x
			positions[count + 2] = face.v[1].y
			positions[count + 3] = face.v[1].z
			positions[count + 4] = face.v[2].x
			positions[count + 5] = face.v[2].y
			positions[count + 6] = face.v[2].z
			positions[count + 7] = face.v[3].x
			positions[count + 8] = face.v[3].y
			positions[count + 9] = face.v[3].z

			normals[count + 1] = face.n[1].x
			normals[count + 2] = face.n[1].y
			normals[count + 3] = face.n[1].z
			normals[count + 4] = face.n[2].x
			normals[count + 5] = face.n[2].y
			normals[count + 6] = face.n[2].z
			normals[count + 7] = face.n[3].x
			normals[count + 8] = face.n[3].y
			normals[count + 9] = face.n[3].z

			count = count + 9
		end

		lights = buffer.create(#SETTINGS.lights, { -- input data for opencl kernel
			{ name = hash("positions"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
			{ name = hash("attn"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		})

		positions = buffer.get_stream(lights, hash("positions"))
		local attn = buffer.get_stream(lights, hash("attn"))

		count = 0
		for _, light in ipairs(SETTINGS.lights) do
			positions[count + 1] = light.pos.x
			positions[count + 2] = light.pos.y
			positions[count + 3] = light.pos.z

			attn[count + 1] = light.attn0
			attn[count + 2] = light.attn1
			attn[count + 3] = light.attn2
		end

		local randoms = buffer.create(512, {
			{ name = hash("data"), type = buffer.VALUE_TYPE_FLOAT32, count = 1 },
		})

		local stream = buffer.get_stream(randoms, hash("data"))
		for i = 1, 512 do
			stream[i] = math.random()
		end

		kernel = program:create_kernel("calculate")
		

		kernel:set_arg_buffer(1, geometry, "positions", true) 
		kernel:set_arg_buffer(2, geometry, "normals", true) 
		kernel:set_arg_buffer(3, lights, "positions", true) 
		kernel:set_arg_buffer(4, lights, "attn", true) 
		kernel:set_arg_buffer(5, randoms, "data", true) 
		kernel:set_arg_int(6, #faces) 
		kernel:set_arg_int(7, #lights) 
		
		

		
		local step = vmath.vector4((self.bounds_max.x - self.bounds_min.x)/(PROBES_PER_ROW -1), (self.bounds_max.y - self.bounds_min.y)/(PROBES_PER_ROW - 1), (self.bounds_max.z - self.bounds_min.z)/(PROBES_PER_ROW - 1), 0)

		for _, mesh in ipairs(meshes) do
			go.set(mesh, "bounds", vmath.vector4(self.bounds_min.x, self.bounds_min.y, self.bounds_min.z, PROBES_PER_ROW))
			go.set(mesh, "step", step)
			go.set(mesh, "size", vmath.vector4(1.0 / (PROBES_PER_ROW * PROBES_PER_ROW), 1.0 /PROBES_PER_ROW, 0, 0))
		end

		local probes = buffer.create(PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW, { 
			{ name = hash("positions"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 }
		})
		positions = buffer.get_stream(probes, hash("positions"))
		count = 0
		
			for z = 0, PROBES_PER_ROW - 1 do
				for y = 0, PROBES_PER_ROW - 1 do
					for x = 0, PROBES_PER_ROW - 1 do
						local pos = vmath.vector3(self.bounds_min.x + step.x * x, self.bounds_min.y  + step.y * y, self.bounds_min.z  + step.z * z)
						local id = factory.create("/probes#factory", pos, nil, {}, vmath.vector3(0.4,0.4,0.4))
						local probe = {id = id, pos = pos, coef = {}}
						probe.model = msg.url(probe.id)
						probe.model.fragment =  "model"

						positions[count + 1] = pos.x
						positions[count + 2] = pos.y
						positions[count + 3] = pos.z

						count = count + 3

						table.insert(self.probes, probe)
						self.count = self.count + 1
					end
				end
			end

			local output = buffer.create(9 * #self.probes, {
				{ name = hash("data"), type = buffer.VALUE_TYPE_FLOAT32, count = 1 }
			})
			

			kernel:set_arg_buffer(8, probes, "positions", true) 
			kernel:set_arg_buffer(9, output, "data", false, true)
			kernel:set_arg_null(10, 4 * 256 * 9)  -- local memory buffer, 256x9 floats for each probe

			
			calculate_probes(self)

			faces = nil
		end)


end

local function transpose(m)
	local res = vmath.matrix4()
	res.m00 = m.m00
	res.m01 = m.m10
	res.m02 = m.m20
	res.m03 = m.m30
	
	res.m10 = m.m01
	res.m11 = m.m11
	res.m12 = m.m21
	res.m13 = m.m31

	res.m20 = m.m02
	res.m21 = m.m12
	res.m22 = m.m22
	res.m23 = m.m32

	res.m30 = m.m03
	res.m31 = m.m13
	res.m32 = m.m23
	res.m33 = m.m33
	

	return res
end


function on_message(self, message_id, message, sender)
	if message_id == hash("register_mesh") then
		local m = go.get_world_transform(sender)
		local n = transpose(vmath.inv(m))
		local url = msg.url(sender)
		url.fragment = "mesh"

		table.insert(meshes, url)
		go.set(url, "mtx_normal_world", n)
		
		local res = go.get(url, "vertices")
		local buf = resource.get_buffer(res)

		
		local position = buffer.get_stream(buf, "position")
		local normal = buffer.get_stream(buf, "normal")
		local i = 1
		while i < #position do
			local v1 = m * vmath.vector4(position[i], position[i+1], position[i+2], 1)
			local v2 = m * vmath.vector4(position[i+3], position[i+4], position[i+5], 1)
			local v3 = m * vmath.vector4(position[i+6], position[i+7], position[i+8], 1)

			local n1 = n * vmath.vector4(normal[i], normal[i+1], normal[i+2], 0)
			local n2 = n * vmath.vector4(normal[i+3], normal[i+4], normal[i+5], 0)
			local n3 = n * vmath.vector4(normal[i+6], normal[i+7], normal[i+8], 0)

			v1 = vmath.vector3(v1.x, v1.y, v1.z)
			v2 = vmath.vector3(v2.x, v2.y, v2.z)
			v3 = vmath.vector3(v3.x, v3.y, v3.z)

			n1 = vmath.vector3(n1.x, n1.y, n1.z)
			n2 = vmath.vector3(n2.x, n2.y, n2.z)
			n3 = vmath.vector3(n3.x, n3.y, n3.z)
			
			i = i + 9
			
			table.insert(faces, {v = {v1, v2, v3}, n = {n1, n2, n3}})
		end

	elseif message_id == hash("update_light") then
		local pos = go.get_world_position(sender)
		SETTINGS.lights[message.light_id].pos = pos
		local positions = buffer.get_stream(lights, hash("positions"))

		positions[(message.light_id - 1) * 3 + 1] = pos.x
		positions[(message.light_id - 1) * 3 + 2] = pos.y
		positions[(message.light_id - 1) * 3 + 3] = pos.z

		kernel:set_arg_buffer(3, lights, "positions", true) 
		

	elseif message_id == hash("register_light") then
		table.insert(SETTINGS.lights, {
			pos = go.get_world_position(sender),
			attn0 = message.attn0,
			attn1 = message.attn1, 
			attn2 = message.attn2
		})

		msg.post(sender, "id_assinged", {light_id = #SETTINGS.lights})
	end
end



function fixed_update(self, dt)
	calculate_probes(self)
end




function update(self)
	local title = "Light probes"
	
	if self.co then
		coroutine.resume(self.co)
		title = title .. " - calculating " .. self.count .. " of " .. PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW
	end

	imgui.set_next_window_size(500, 200)

	imgui.begin_window(title)

	local changed, checked = imgui.checkbox("show probes", SETTINGS.probes)
	if changed then
		SETTINGS.probes = not SETTINGS.probes
	end

	changed, checked = imgui.checkbox("textures", SETTINGS.textures)
	if changed then
		SETTINGS.textures = not SETTINGS.textures
	end

	changed, checked = imgui.checkbox("direct light", SETTINGS.direct)
	if changed then
		SETTINGS.direct = not SETTINGS.direct
	end

	changed, checked = imgui.checkbox("indirect light", SETTINGS.indirect)
	if changed then
		SETTINGS.indirect = not SETTINGS.indirect
	end

	changed, checked = imgui.checkbox("direct from probes", SETTINGS.direct2)
	if changed then
		SETTINGS.direct2 = not SETTINGS.direct2
	end

	imgui.end_window()
end

