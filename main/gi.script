go.property('bounds_min', vmath.vector3(-10, -10, -10))
go.property('bounds_max', vmath.vector3(10, 10, 10))

local SETTINGS = require "settings"

local geometry
local lights
local faces = {}
local meshes = {}

local PROBES_PER_ROW = 4
local RAYS =  256

local BIAS = 0.01

local tbuffer
local device
local program
local kernel


local function load_probes_into_texture(probes)
	--each probe (9 sh coefficients) will be stored in 3 rgb texels
		
	local tstream = buffer.get_stream(tbuffer, hash("rgb"))

	-- Fill the buffer stream with float values

	local index = 1
	for y = 1, PROBES_PER_ROW do
		for x = 1, PROBES_PER_ROW do
			for z = 1, PROBES_PER_ROW do
				local pi = (y - 1) * PROBES_PER_ROW * PROBES_PER_ROW + (x-1) * PROBES_PER_ROW + z
				local probe = probes[pi]
	
				tstream[index + 0] = probe.coef[1]
				tstream[index + 1] = probe.coef[2]
				tstream[index + 2] = probe.coef[3]
				
				tstream[index + 3] = probe.coef[4]
				tstream[index + 4] = probe.coef[5]
				tstream[index + 5] = probe.coef[6]
				
				tstream[index + 6] = probe.coef[7]
				tstream[index + 7] = probe.coef[8]
				tstream[index + 8] = probe.coef[9]

				index = index + 9
			end
		end
	end

	local tparams = {
		width          = PROBES_PER_ROW * PROBES_PER_ROW * 3,
		height         = PROBES_PER_ROW,
		type           = resource.TEXTURE_TYPE_2D,
		format         = resource.TEXTURE_FORMAT_RGB32F,
	}

	-- Note that we pass the buffer as the last argument here!
	local my_texture_id = resource.create_texture("/probes.texturec", tparams, tbuffer)

	-- assign the texture to a model
	for _, mesh in ipairs(meshes) do
		go.set(mesh, "texture1", my_texture_id)
	end

	go.set("/preview#mesh", "texture0", my_texture_id)
end

--https://handmade.network/p/75/monter/blog/p/7288-engine_work__global_illumination_with_irradiance_probes
--https://www.ppsloan.org/publications/StupidSH36.pdf    ---Appendix A2
local function sh(dir, basis)

	if basis == 1 then
		return 0.28209479177387814347
	end
	
	if basis == 2 then
		return -0.48860251190291992159 * dir[2]
	end
	
	if basis == 3 then
		return 0.48860251190291992159 * dir[3]
	end

	if basis == 4 then
		return  -0.48860251190291992159 * dir[1]
	end

	if basis == 5 then
		return 1.092548430592079 * dir[1] * dir[2]
	end

	if basis == 6 then
		return -1.092548430592079 * dir[3] * dir[2]
	end

	if basis == 7 then
		return 0.31539156525252 * (3 * dir[3] * dir[3] - 1)
	end

	if basis == 8 then
		return -1.092548430592079 * dir[3] * dir[1]
	end

	if basis == 9 then
		return 0.54627421529604 * (dir[1] * dir[1] - dir[2] * dir[2])
	end

	return 0.0
end

	
local function calculate_probe(self, probe)
	local num_coef = 9
	probe.coef = {0, 0, 0, 0, 0, 0, 0, 0, 0}

	--kernel:set_arg_vec3(6, {probe.pos.x, probe.pos.y, probe.pos.z}) 
	kernel:set_arg_vec3(8, {probe.pos.x,probe.pos.y,probe.pos.z}) 
	local sec = kernel:run(1, {256}, {256})
	--pprint("Kernel run in " .. sec .. " seconds")
	local data = kernel:read(9, 9)
	for i = 1, num_coef do 
		probe.coef[i] = data[i];
	end
	
end

function init(self)

	tbuffer = buffer.create(PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW * 3, { {name=hash("rgb"), type=buffer.VALUE_TYPE_FLOAT32, count=3} } )
	
	local src = sys.load_resource("/programs/raytrace.c") -- opencl kernel code
	local devices = opencl.get_devices()

	device = devices[2]

	program = device:load_program(src)
	kernel = program:create_kernel("calculate")
	
	--self.program = devices[1]:load_program(src)
	--self.kernel = program:create_kernel("cast_ray")


	imgui.set_ini_filename()
	self.count = 0
	self.probes = {}
	math.randomseed(os.clock()*100000)

	timer.delay(.1, false, function()

		geometry = buffer.create(#faces * 3, { -- input data for opencl kernel
			{ name = hash("positions"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
			{ name = hash("normals"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		})

		local positions = buffer.get_stream(geometry, hash("positions"))
		local normals = buffer.get_stream(geometry, hash("normals"))

		local count = 0
		for _, face in ipairs(faces) do
			positions[count + 1] = face.v[1].x
			positions[count + 2] = face.v[1].y
			positions[count + 3] = face.v[1].z
			positions[count + 4] = face.v[2].x
			positions[count + 5] = face.v[2].y
			positions[count + 6] = face.v[2].z
			positions[count + 7] = face.v[3].x
			positions[count + 8] = face.v[3].y
			positions[count + 9] = face.v[3].z

			normals[count + 1] = face.n[1].x
			normals[count + 2] = face.n[1].y
			normals[count + 3] = face.n[1].z
			normals[count + 4] = face.n[2].x
			normals[count + 5] = face.n[2].y
			normals[count + 6] = face.n[2].z
			normals[count + 7] = face.n[3].x
			normals[count + 8] = face.n[3].y
			normals[count + 9] = face.n[3].z

			count = count + 9
		end

		lights = buffer.create(#SETTINGS.lights, { -- input data for opencl kernel
			{ name = hash("positions"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
			{ name = hash("attn"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		})

		positions = buffer.get_stream(lights, hash("positions"))
		local attn = buffer.get_stream(lights, hash("attn"))

		count = 0
		for _, light in ipairs(SETTINGS.lights) do
			positions[count + 1] = light.pos.x
			positions[count + 2] = light.pos.y
			positions[count + 3] = light.pos.z

			attn[count + 1] = light.attn0
			attn[count + 2] = light.attn1
			attn[count + 3] = light.attn2
		end

		local output = buffer.create(9, {
			{ name = hash("data"), type = buffer.VALUE_TYPE_FLOAT32, count = 1 }
		})

		local randoms = buffer.create(512, {
			{ name = hash("data"), type = buffer.VALUE_TYPE_FLOAT32, count = 1 },
		})

		local stream = buffer.get_stream(randoms, hash("data"))
		for i = 1, 512 do
			stream[i] = math.random()
		end
		

		kernel:set_arg_buffer(1, geometry, "positions", true) 
		kernel:set_arg_buffer(2, geometry, "normals", true) 
		kernel:set_arg_buffer(3, lights, "positions", true) 
		kernel:set_arg_buffer(4, lights, "attn", true) 
		kernel:set_arg_buffer(5, randoms, "data", true) 
		kernel:set_arg_int(6, #faces) 
		kernel:set_arg_int(7, #lights) 
		
		kernel:set_arg_buffer(9, output, "data", true, true)
		kernel:set_arg_null(10, 4 * 256 * 9)  --local memeory buffer, 256x9 floats
		
		
		local step = vmath.vector4((self.bounds_max.x - self.bounds_min.x)/(PROBES_PER_ROW -1), (self.bounds_max.y - self.bounds_min.y)/(PROBES_PER_ROW - 1), (self.bounds_max.z - self.bounds_min.z)/(PROBES_PER_ROW - 1), 0)

		for _, mesh in ipairs(meshes) do
			go.set(mesh, "bounds", vmath.vector4(self.bounds_min.x, self.bounds_min.y, self.bounds_min.z, PROBES_PER_ROW))
			go.set(mesh, "step", step)
			go.set(mesh, "size", vmath.vector4(1.0 / (PROBES_PER_ROW * PROBES_PER_ROW), 1.0 /PROBES_PER_ROW, 0, 0))
		end
		
		--self.co = coroutine.create(function()
			for z = 0, PROBES_PER_ROW - 1 do
				for y = 0, PROBES_PER_ROW -1 do
					for x = 0, PROBES_PER_ROW  - 1 do
						local pos = vmath.vector3(self.bounds_min.x + step.x * x, self.bounds_min.y  + step.y * y, self.bounds_min.z  + step.z * z)
						local id = factory.create("/probes#factory", pos, nil, {}, vmath.vector3(0.4,0.4,0.4))
						local probe = {id = id, pos = pos}
						calculate_probe(self, probe)

						local model = msg.url(probe.id)
						model.fragment =  "model"

						--[[
						probe.coef = {0,0,0,0,0,0,0,0,0}
						probe.coef[1] = 0.25 * x
						probe.coef[2] = 0.25 * y
						probe.coef[3] = 0.25 * z
						probe.coef[4] = 1.
						--]]
						
						go.set(model, "coefs", vmath.vector4(probe.coef[1], probe.coef[2], probe.coef[3], probe.coef[4]), {index = 1})
						go.set(model, "coefs", vmath.vector4(probe.coef[5], probe.coef[6], probe.coef[7], probe.coef[8]), {index = 2})
						go.set(model, "coefs", vmath.vector4(probe.coef[9], 0, 0, 0), {index = 3})

						table.insert(self.probes, probe)
						self.count = self.count + 1
						--coroutine.yield()
					end
				end
			end
			self.co = nil

			load_probes_into_texture(self.probes)
			faces = nil
		end)

		--coroutine.resume(self.co)
--	end)
end

local function transpose(m)
	local res = vmath.matrix4()
	res.m00 = m.m00
	res.m01 = m.m10
	res.m02 = m.m20
	res.m03 = m.m30
	
	res.m10 = m.m01
	res.m11 = m.m11
	res.m12 = m.m21
	res.m13 = m.m31

	res.m20 = m.m02
	res.m21 = m.m12
	res.m22 = m.m22
	res.m23 = m.m32

	res.m30 = m.m03
	res.m31 = m.m13
	res.m32 = m.m23
	res.m33 = m.m33
	

	return res
end


function on_message(self, message_id, message, sender)
	if message_id == hash("register_mesh") then
		local m = go.get_world_transform(sender)
		local n = transpose(vmath.inv(m))
		local url = msg.url(sender)
		url.fragment = "mesh"

		table.insert(meshes, url)
		go.set(url, "mtx_normal_world", n)
		
		local res = go.get(url, "vertices")
		local buf = resource.get_buffer(res)

		
		local position = buffer.get_stream(buf, "position")
		local normal = buffer.get_stream(buf, "normal")
		local i = 1
		while i < #position do
			local v1 = m * vmath.vector4(position[i], position[i+1], position[i+2], 1)
			local v2 = m * vmath.vector4(position[i+3], position[i+4], position[i+5], 1)
			local v3 = m * vmath.vector4(position[i+6], position[i+7], position[i+8], 1)

			local n1 = n * vmath.vector4(normal[i], normal[i+1], normal[i+2], 0)
			local n2 = n * vmath.vector4(normal[i+3], normal[i+4], normal[i+5], 0)
			local n3 = n * vmath.vector4(normal[i+6], normal[i+7], normal[i+8], 0)

			v1 = vmath.vector3(v1.x, v1.y, v1.z)
			v2 = vmath.vector3(v2.x, v2.y, v2.z)
			v3 = vmath.vector3(v3.x, v3.y, v3.z)

			n1 = vmath.vector3(n1.x, n1.y, n1.z)
			n2 = vmath.vector3(n2.x, n2.y, n2.z)
			n3 = vmath.vector3(n3.x, n3.y, n3.z)
			
			i = i + 9
			
			table.insert(faces, {v = {v1, v2, v3}, n = {n1, n2, n3}})
		end

		
	elseif message_id == hash("register_light") then
		table.insert(SETTINGS.lights, {
			pos = go.get_world_position(sender),
			attn0 = message.attn0,
			attn1 = message.attn1, 
			attn2 = message.attn2
		})
	end
end

--[[
function fixed_pdate(self)
	for _,p in ipairs(self.probes) do
		calculate_probe(self, probe)
	end 
end
--]]

function update(self)
	local title = "Light probes"
	
	if self.co then
		coroutine.resume(self.co)
		title = title .. " - calculating " .. self.count .. " of " .. PROBES_PER_ROW * PROBES_PER_ROW * PROBES_PER_ROW
	end

	imgui.set_next_window_size(500, 200)

	imgui.begin_window(title)

	local changed, checked = imgui.checkbox("show probes", SETTINGS.probes)
	if changed then
		SETTINGS.probes = not SETTINGS.probes
	end

	changed, checked = imgui.checkbox("textures", SETTINGS.textures)
	if changed then
		SETTINGS.textures = not SETTINGS.textures
	end

	changed, checked = imgui.checkbox("direct light", SETTINGS.direct)
	if changed then
		SETTINGS.direct = not SETTINGS.direct
	end

	changed, checked = imgui.checkbox("indirect light", SETTINGS.indirect)
	if changed then
		SETTINGS.indirect = not SETTINGS.indirect
	end

	changed, checked = imgui.checkbox("direct from probes", SETTINGS.direct2)
	if changed then
		SETTINGS.direct2 = not SETTINGS.direct2
	end

	imgui.end_window()
end

